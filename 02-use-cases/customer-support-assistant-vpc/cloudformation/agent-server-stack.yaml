AWSTemplateFormatVersion: '2010-09-09'
Description: 'Bedrock AgentCore agent runtime with HTTP protocol. Deploys containerized agent in ECR with access to MCP servers, Gateway tools, and Aurora database. Includes CodeBuild pipeline for Docker builds, OAuth2 provider setup, and EventBridge automation for container updates.'


Metadata:
  'AWS::CloudFormation::Interface':
    ParameterGroups:
    - Label:
        default: 'Environment Configuration'
      Parameters:
      - Environment
      - ModelID
    - Label:
        default: 'Stack References'
      Parameters:
      - VPCStackName
      - CognitoStackName
      - MCPStackName
      - GatewayStackName
      - AuroraStackName

Parameters:
  Environment:
    Type: String
    Default: 'dev'
    AllowedValues:
      - dev
      - test
      - prod
    Description: 'Environment name for resource naming'

  VPCStackName:
    Type: String
    Description: 'Name of the VPC stack to reference for network configuration'

  CognitoStackName:
    Type: String
    Description: 'Name of the Cognito stack to reference for client configuration'

  MCPStackName:
    Type: String
    Description: 'Name of the MCP stack to reference for MCP runtime ARN'

  GatewayStackName:
    Type: String
    Description: 'Name of the Gateway stack to reference for MCP ENV'

  AuroraStackName:
    Type: String
    Description: 'Name of the Aurora stack to reference for database connection'

  ModelID:
    Type: String
    Default: 'global.anthropic.claude-sonnet-4-20250514-v1:0'
    Description: 'Name of the model to use with Agent'

Resources:
  # ECR Repository for Agent Docker Images
  AgentECRRepository:
    Type: AWS::ECR::Repository
    Properties:
      RepositoryName: !Sub 'csvpc-${Environment}-agent-repository'
      ImageScanningConfiguration:
        ScanOnPush: true
      LifecyclePolicy:
        LifecyclePolicyText: |
          {
            "rules": [
              {
                "rulePriority": 1,
                "selection": {
                  "tagStatus": "untagged",
                  "countType": "sinceImagePushed",
                  "countUnit": "days",
                  "countNumber": 1
                },
                "action": {
                  "type": "expire"
                }
              },
              {
                "rulePriority": 2,
                "selection": {
                  "tagStatus": "tagged",
                  "tagPrefixList": ["v", "latest", "main", "master"],
                  "countType": "imageCountMoreThan",
                  "countNumber": 10
                },
                "action": {
                  "type": "expire"
                }
              }
            ]
          }
      Tags:
        - Key: Name
          Value: !Sub 'csvpc-${Environment}-Agent-ECR'
        - Key: Purpose
          Value: 'Agent Docker Images'
    DeletionPolicy: Delete

  # AgentCore Runtime Execution Role
  AgentCoreRuntimeExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub 'csvpc-${Environment}-agent-runtime-execution-role'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Sid: AssumeRolePolicy
            Effect: Allow
            Principal:
              Service: bedrock-agentcore.amazonaws.com
            Action: sts:AssumeRole
            Condition:
              StringEquals:
                'aws:SourceAccount': !Ref AWS::AccountId
              ArnLike:
                'aws:SourceArn': !Sub 'arn:aws:bedrock-agentcore:${AWS::Region}:${AWS::AccountId}:*'
      Policies:
        - PolicyName: AgentCoreRuntimeExecutionPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Sid: ECRImageAccess
                Effect: Allow
                Action:
                  - ecr:BatchGetImage
                  - ecr:GetDownloadUrlForLayer
                Resource:
                  - !Sub 'arn:aws:ecr:${AWS::Region}:${AWS::AccountId}:repository/*'
              - Effect: Allow
                Action:
                  - logs:DescribeLogStreams
                  - logs:CreateLogGroup
                Resource:
                  - !Sub 'arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/bedrock-agentcore/runtimes/*'
              - Effect: Allow
                Action:
                  - logs:DescribeLogGroups
                Resource:
                  - !Sub 'arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:*'
              - Effect: Allow
                Action:
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource:
                  - !Sub 'arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/bedrock-agentcore/runtimes/*:log-stream:*'
              - Sid: ECRTokenAccess
                Effect: Allow
                Action:
                  - ecr:GetAuthorizationToken
                Resource: '*'
              - Effect: Allow
                Action:
                  - xray:PutTraceSegments
                  - xray:PutTelemetryRecords
                  - xray:GetSamplingRules
                  - xray:GetSamplingTargets
                Resource: '*'
              - Effect: Allow
                Resource: '*'
                Action: cloudwatch:PutMetricData
                Condition:
                  StringEquals:
                    'cloudwatch:namespace': 'bedrock-agentcore'
              - Sid: GetAgentAccessToken
                Effect: Allow
                Action:
                  - bedrock-agentcore:GetWorkloadAccessToken
                  - bedrock-agentcore:GetWorkloadAccessTokenForJWT
                  - bedrock-agentcore:GetWorkloadAccessTokenForUserId
                Resource:
                  - !Sub 'arn:aws:bedrock-agentcore:${AWS::Region}:${AWS::AccountId}:workload-identity-directory/default'
                  - !Sub 'arn:aws:bedrock-agentcore:${AWS::Region}:${AWS::AccountId}:workload-identity-directory/default/workload-identity/csvpcAgentRuntime*'
              - Sid: BedrockModelAccess
                Effect: Allow
                Action:
                  - bedrock:InvokeModel
                  - bedrock:InvokeModelWithResponseStream
                Resource:
                  - 'arn:aws:bedrock:*::foundation-model/*'
                  - !Sub 'arn:aws:bedrock:${AWS::Region}:${AWS::AccountId}:*'
              - Sid: SSMParameterAccess
                Effect: Allow
                Action:
                  - ssm:GetParameter
                  - ssm:GetParameters
                Resource:
                  - !Sub 'arn:aws:ssm:${AWS::Region}:${AWS::AccountId}:parameter/app/customersupportvpc/gateway/gateway_url'
              - Sid: Oauth2Token
                Effect: Allow
                Action:
                  - bedrock-agentcore:GetResourceOauth2Token
                  # TODO: Scope down
                Resource:
                  - '*'
              - Sid: SecretsManager
                Effect: Allow
                Action:
                  - secretsmanager:GetSecretValue
                  # TODO: Scope down
                Resource:
                  - '*'
              - Sid: RDSDataAPIAccess
                Effect: Allow
                Action:
                  - rds-data:ExecuteStatement
                  - rds-data:BatchExecuteStatement
                  - rds-data:BeginTransaction
                  - rds-data:CommitTransaction
                  - rds-data:RollbackTransaction
                Resource:
                  Fn::ImportValue: !Sub '${AuroraStackName}-ClusterArn'
              - Sid: AuroraSecretAccess
                Effect: Allow
                Action:
                  - secretsmanager:GetSecretValue
                Resource:
                  Fn::ImportValue: !Sub '${AuroraStackName}-DBCredentialsSecret'
      Tags:
        - Key: Name
          Value: !Sub 'csvpc-${Environment}-AgentCore-Runtime-Role'
        - Key: Purpose
          Value: 'AgentCore Runtime Execution'

  # CodeBuild Service Role for Docker Image Build
  CodeBuildServiceRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: codebuild.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: CodeBuildLogsPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource:
                  - "*"
        - PolicyName: ECRAccessPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - ecr:BatchCheckLayerAvailability
                  - ecr:GetDownloadUrlForLayer
                  - ecr:BatchGetImage
                  - ecr:GetAuthorizationToken
                Resource: '*'
              - Effect: Allow
                Action:
                  - ecr:InitiateLayerUpload
                  - ecr:UploadLayerPart
                  - ecr:CompleteLayerUpload
                  - ecr:PutImage
                Resource: !GetAtt AgentECRRepository.Arn
      Tags:
        - Key: Name
          Value: !Sub 'csvpc-${Environment}-CodeBuild-Role'
        - Key: Purpose
          Value: 'CodeBuild Docker Image Build'

  # CodeBuild Project for Agent Docker Image
  AgentDockerBuildProject:
    Type: AWS::CodeBuild::Project
    Properties:
      Name: !Sub 'csvpc-${Environment}-agent-docker-build'
      Description: 'Build and push agent Docker image to ECR'
      ServiceRole: !GetAtt CodeBuildServiceRole.Arn
      Artifacts:
        Type: NO_ARTIFACTS
      Environment:
        Type: ARM_CONTAINER
        ComputeType: BUILD_GENERAL1_LARGE
        Image: aws/codebuild/amazonlinux2-aarch64-standard:3.0
        PrivilegedMode: true
        EnvironmentVariables:
          - Name: ECR_REPOSITORY_URI
            Value: !Sub '${AWS::AccountId}.dkr.ecr.${AWS::Region}.amazonaws.com/${AgentECRRepository}'
          - Name: ECR_REPOSITORY_NAME
            Value: !Ref AgentECRRepository
          - Name: AWS_DEFAULT_REGION
            Value: !Ref AWS::Region
          - Name: AWS_ACCOUNT_ID
            Value: !Ref AWS::AccountId
      Source:
        Type: GITHUB
        Location: 'https://github.com/awslabs/amazon-bedrock-agentcore-samples.git'
        GitCloneDepth: 1
        BuildSpec: |
          version: 0.2
          phases:
            pre_build:
              commands:
                - echo "Checking current directory and contents..."
                - pwd
                - ls -la
                - echo "Navigating to agent directory..."
                - cd 02-use-cases/customer-support-assistant-vpc/agent
                - echo "Contents of agent directory:"
                - ls -la
                - echo "Checking for Dockerfile..."
                - cat Dockerfile || echo "Dockerfile not found"
                - echo "Generating unique image tag..."
                - export IMAGE_TAG="build-${CODEBUILD_BUILD_NUMBER}"
                - echo "Image will be tagged as ${IMAGE_TAG}"
            build:
              commands:
                - echo "Starting parallel Docker build and ECR authentication..."
                - |
                  docker build -t bedrock-agentcore-arm64 . &
                  BUILD_PID=$!
                  aws ecr get-login-password --region $AWS_DEFAULT_REGION | \
                  docker login --username AWS --password-stdin $ECR_REPOSITORY_URI &
                  AUTH_PID=$!
                  echo "Waiting for Docker build to complete..."
                  wait $BUILD_PID
                  if [ $? -ne 0 ]; then
                    echo "Docker build failed"
                    exit 1
                  fi
                  echo "Waiting for ECR authentication to complete..."
                  wait $AUTH_PID
                  if [ $? -ne 0 ]; then
                    echo "ECR authentication failed"
                    exit 1
                  fi
                  echo "Both build and auth completed successfully"
                - echo "Tagging image with unique tag ${IMAGE_TAG}..."
                - docker tag bedrock-agentcore-arm64:latest $ECR_REPOSITORY_URI:${IMAGE_TAG}
            post_build:
              commands:
                - echo "Pushing ARM64 image to ECR with unique tag ${IMAGE_TAG}..."
                - docker push $ECR_REPOSITORY_URI:${IMAGE_TAG}
                - echo "Build completed at $(date)"
                - echo "Image tag pushed - ${IMAGE_TAG}"
      TimeoutInMinutes: 30
      Tags:
        - Key: Name
          Value: !Sub 'csvpc-${Environment}-Agent-Docker-Build'
        - Key: Purpose
          Value: 'Agent Docker Image Build'

  # Lambda Execution Role for ECR Image Notification
  ECRImageNotificationLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: ECRAccessPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - ecr:DescribeImages
                  - ecr:ListImages
                Resource: !GetAtt AgentECRRepository.Arn
        - PolicyName: BedrockAgentCoreAccessPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - bedrock-agentcore:ListAgentRuntimes
                  - bedrock-agentcore:ListAgentRuntimeEndpoints
                  - bedrock-agentcore:ListAgentRuntimeVersions
                  - bedrock-agentcore:GetAgentRuntime
                  - bedrock-agentcore:GetAgentRuntimeEndpoint
                  - bedrock-agentcore:UpdateAgentRuntime
                  - bedrock-agentcore:UpdateAgentRuntimeEndpoint
                Resource: '*'
        - PolicyName: IAMPassRole
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - iam:PassRole
                Resource: !GetAtt AgentCoreRuntimeExecutionRole.Arn
      Tags:
        - Key: Name
          Value: !Sub 'csvpc-${Environment}-ECR-Notification-Role'
        - Key: Purpose
          Value: 'ECR Image Notification Lambda'

  # Lambda Function for ECR Image Notification
  ECRImageNotificationFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub 'csvpc-${Environment}-agent-ecr-notification'
      Runtime: python3.12
      Handler: index.lambda_handler
      Role: !GetAtt ECRImageNotificationLambdaRole.Arn
      Timeout: 300
      Environment:
        Variables:
          AGENT_RUNTIME_ID: !GetAtt AgentRuntime.AgentRuntimeId
          ECR_REPOSITORY_URI: !Sub '${AWS::AccountId}.dkr.ecr.${AWS::Region}.amazonaws.com/${AgentECRRepository}'
          ROLE_ARN: !GetAtt AgentCoreRuntimeExecutionRole.Arn
      Code:
        ZipFile: |
          import json
          import logging
          import boto3
          import os

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          def lambda_handler(event, context):
              try:
                  logger.info(f"Received ECR event: {json.dumps(event)}")

                  # Parse the ECR event
                  detail = event.get('detail', {})
                  repository_name = detail.get('repository-name')
                  image_tag = detail.get('image-tag', 'latest')
                  action = detail.get('action-type')
                  result = detail.get('result')

                  logger.info(f"ECR Event - Repository: {repository_name}, Tag: {image_tag}, Action: {action}, Result: {result}")

                  # Only proceed if the push was successful
                  if action != 'PUSH' or result != 'SUCCESS':
                      logger.info("Skipping non-push or failed event")
                      return {
                          'statusCode': 200,
                          'body': json.dumps('Event skipped - not a successful push')
                      }

                  # Get environment variables
                  agent_runtime_id = os.environ['AGENT_RUNTIME_ID']
                  ecr_repository_uri = os.environ['ECR_REPOSITORY_URI']
                  role_arn = os.environ['ROLE_ARN']

                  # Initialize bedrock-agentcore-control client
                  client = boto3.client('bedrock-agentcore-control')

                  # Get current runtime configuration
                  logger.info(f"Getting current runtime configuration for: {agent_runtime_id}")
                  get_response = client.get_agent_runtime(agentRuntimeId=agent_runtime_id)

                  logger.info(f"Current runtime status: {get_response}")

                  # Build new container URI with the pushed image tag
                  new_container_uri = f"{ecr_repository_uri}:{image_tag}"

                  logger.info(f"Updating runtime to use new container: {new_container_uri}")

                  # Update the runtime with the new container image
                  update_response = client.update_agent_runtime(
                      agentRuntimeId=agent_runtime_id,
                      agentRuntimeArtifact={
                          'containerConfiguration': {
                              'containerUri': new_container_uri
                          }
                      },
                      roleArn=role_arn,
                      networkConfiguration=get_response['networkConfiguration'],
                      protocolConfiguration=get_response['protocolConfiguration'],
                      authorizerConfiguration=get_response['authorizerConfiguration'],
                      environmentVariables=get_response['environmentVariables'],
                  )

                  logger.info(f"Runtime updated successfully. New version: {update_response['agentRuntimeVersion']}")

                  return {
                      'statusCode': 200,
                      'body': json.dumps({
                          'message': 'AgentCore Runtime updated successfully',
                          'newContainerUri': new_container_uri,
                          'runtimeId': agent_runtime_id,
                          'newVersion': update_response['agentRuntimeVersion']
                      })
                  }

              except Exception as e:
                  logger.error(f"Error processing ECR event: {str(e)}", exc_info=True)
                  return {
                      'statusCode': 500,
                      'body': json.dumps({'error': str(e)})
                  }
      Tags:
        - Key: Name
          Value: !Sub 'csvpc-${Environment}-ECR-Notification-Function'

  # EventBridge Permission for Lambda
  ECRImageNotificationLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref ECRImageNotificationFunction
      Action: lambda:InvokeFunction
      Principal: events.amazonaws.com
      SourceArn: !GetAtt ECRImageEventRule.Arn

  # EventBridge Rule for ECR Image Push
  ECRImageEventRule:
    Type: AWS::Events::Rule
    Properties:
      Name: !Sub 'csvpc-${Environment}-agent-ecr-push-rule'
      Description: 'Trigger Lambda when new ECR image is pushed'
      EventPattern:
        source:
          - aws.ecr
        detail-type:
          - ECR Image Action
        detail:
          action-type:
            - PUSH
          result:
            - SUCCESS
          repository-name:
            - !Ref AgentECRRepository
      State: ENABLED
      Targets:
        - Arn: !GetAtt ECRImageNotificationFunction.Arn
          Id: ECRImageNotificationTarget

  # Lambda Execution Role for CodeBuild Trigger
  CodeBuildTriggerLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: CodeBuildTriggerPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - codebuild:StartBuild
                  - codebuild:BatchGetBuilds
                Resource: !GetAtt AgentDockerBuildProject.Arn
        - PolicyName: SecretsManagerAccessPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              # - Effect: Allow
              #   Action:
              #     - secretsmanager:GetSecretValue
              #   Resource:
              #     - Fn::ImportValue: !Sub '${CognitoStackName}-WebUserPoolClientSecret'
              - Effect: Allow
                Action:
                  - kms:Decrypt
                  - kms:GenerateDataKey
                Resource:
                  Fn::ImportValue: !Sub '${CognitoStackName}-SecretsManagerKMSKeyArn'
        - PolicyName: BedrockIdentityAccessPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - bedrock-agentcore:GetResourceOauth2Token
                  - bedrock-agentcore:CreateOauth2CredentialProvider
                  - bedrock-agentcore:DeleteOauth2CredentialProvider
                  - bedrock-agentcore:UpdateOauth2CredentialProvider
                  - bedrock-agentcore:ListOauth2CredentialProviders
                  - bedrock-agentcore:GetOauth2CredentialProvider
                Resource: '*'
        - PolicyName: ECRCleanupPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - ecr:ListImages
                  - ecr:BatchDeleteImage
                Resource: !GetAtt AgentECRRepository.Arn
              - Effect: Allow
                Action:
                  - kms:Decrypt
                  - kms:GenerateDataKey
                Resource:
                  Fn::ImportValue: !Sub '${CognitoStackName}-SecretsManagerKMSKeyArn'
              - Effect: Allow
                Action:
                  - secretsmanager:CreateSecret
                  - secretsmanager:DeleteSecret
                Resource: '*'
              - Effect: Allow
                Action:
                  - bedrock-agentcore:ListWorkloadIdentities
                  - bedrock-agentcore:UpdateWorkloadIdentity
                  - bedrock-agentcore:DeleteWorkloadIdentity
                  - bedrock-agentcore:CreateWorkloadIdentity
                Resource:
                  - !Sub 'arn:aws:bedrock-agentcore:${AWS::Region}:${AWS::AccountId}:workload-identity-directory/*/workload-identity/*'
                  - !Sub 'arn:aws:bedrock-agentcore:${AWS::Region}:${AWS::AccountId}:workload-identity-directory/*'
              - Effect: Allow
                Action:
                  - bedrock-agentcore:GetResourceOauth2Token
                  - bedrock-agentcore:CreateOauth2CredentialProvider
                  - bedrock-agentcore:DeleteOauth2CredentialProvider
                  - bedrock-agentcore:UpdateOauth2CredentialProvider
                  - bedrock-agentcore:ListOauth2CredentialProviders
                  - bedrock-agentcore:GetOauth2CredentialProvider
                Resource: '*'
              - Effect: Allow
                Action:
                  - bedrock-agentcore:GetTokenVault
                  - bedrock-agentcore:CreateTokenVault
                  - bedrock-agentcore:DeleteTokenVault
                Resource: '*'
      Tags:
        - Key: Name
          Value: !Sub 'csvpc-${Environment}-CodeBuild-Trigger-Role'
        - Key: Purpose
          Value: 'CodeBuild Trigger Lambda'

  # Lambda Function to Trigger CodeBuild
  CodeBuildTriggerFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub 'csvpc-${Environment}-agent-codebuild'
      Runtime: python3.12
      Handler: index.lambda_handler
      Role: !GetAtt CodeBuildTriggerLambdaRole.Arn
      Timeout: 900
      Environment:
        Variables:
          CODEBUILD_PROJECT_NAME: !Ref AgentDockerBuildProject
          # AGENT_CLIENT_SECRET_ARN:
          #   Fn::ImportValue: !Sub '${CognitoStackName}-WebUserPoolClientSecret'
          DISCOVERY_URL: !Sub
            - 'https://cognito-idp.${AWS::Region}.amazonaws.com/${UserPoolId}/.well-known/openid-configuration'
            - UserPoolId:
                Fn::ImportValue: !Sub '${CognitoStackName}-UserPoolId'
          ECR_REPOSITORY_NAME: !Ref AgentECRRepository
      Code:
        ZipFile: |
          import json
          import boto3
          import urllib3
          import logging
          import os
          import time

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          # def create_oauth2_credential_provider(secret_arn, discovery_url, provider_name):
          #     try:
          #         logger.info(f"Creating OAuth2 credential provider for Agent: {provider_name}")

          #         # Get client credentials from Secrets Manager
          #         secrets_client = boto3.client('secretsmanager')
          #         secret_response = secrets_client.get_secret_value(SecretId=secret_arn)
          #         secret_data = json.loads(secret_response['SecretString'])

          #         client_id = secret_data['client_id']
          #         client_secret = secret_data['client_secret']
          #         token_url = secret_data['token_endpoint']
          #         auth_url = discovery_url.replace('/.well-known/openid-configuration', '/oauth2/authorize')

          #         # Create OAuth2 credential provider
          #         identity_client = boto3.client("bedrock-agentcore-control",)

          #         identity_client.create_oauth2_credential_provider(
          #             name=provider_name,
          #             credentialProviderVendor="CustomOauth2",
          #             oauth2ProviderConfigInput={
          #                 "customOauth2ProviderConfig": {
          #                     "clientId": client_id,
          #                     "clientSecret": client_secret,
          #                     "oauthDiscovery": {
          #                       "discoveryUrl": discovery_url
          #                     },
          #                 }
          #             },
          #         )

          #         logger.info(f"OAuth2 credential provider created: {provider_name}")
          #         return provider_name

          #     except Exception as e:
          #         logger.error(f"Failed to create OAuth2 credential provider: {str(e)}")
          #         raise e

          def empty_ecr_repository(repository_name):
              try:
                  logger.info(f"Emptying ECR repository: {repository_name}")

                  ecr_client = boto3.client('ecr')

                  # List all images in the repository
                  response = ecr_client.list_images(repositoryName=repository_name)

                  if not response['imageIds']:
                      logger.info("Repository is already empty")
                      return

                  # Delete all images
                  logger.info(f"Deleting {len(response['imageIds'])} images from repository")
                  ecr_client.batch_delete_image(
                      repositoryName=repository_name,
                      imageIds=response['imageIds']
                  )

                  logger.info(f"Successfully emptied ECR repository: {repository_name}")

              except Exception as e:
                  logger.error(f"Failed to empty ECR repository: {str(e)}")
                  # Don't raise the exception, as we want deletion to continue

          def lambda_handler(event, context):
              try:
                  logger.info(f"Received event: {json.dumps(event)}")

                  request_type = event['RequestType']
                  project_name = os.environ['CODEBUILD_PROJECT_NAME']
                  # agent_client_secret_arn = os.environ['AGENT_CLIENT_SECRET_ARN']
                  discovery_url = os.environ['DISCOVERY_URL']
                  provider_name = event['ResourceProperties']['ProviderName']
                  ecr_repository_name = os.environ['ECR_REPOSITORY_NAME']

                  if request_type == 'Create':
                      # Create OAuth2 credential provider first
                      # create_oauth2_credential_provider(agent_client_secret_arn, discovery_url, provider_name)
                      # Start CodeBuild project on stack creation and wait for completion
                      codebuild = boto3.client('codebuild')

                      logger.info(f"Starting CodeBuild project: {project_name}")

                      response = codebuild.start_build(projectName=project_name)
                      build_id = response['build']['id']

                      logger.info(f"Build started successfully with ID: {build_id}")

                      # Wait for build to complete
                      max_wait_time = 1800  # 30 minutes
                      wait_interval = 30    # 30 seconds
                      elapsed_time = 0

                      while elapsed_time < max_wait_time:
                          # Check remaining Lambda execution time
                          remaining_time = context.get_remaining_time_in_millis()
                          if remaining_time < 60000:  # Less than 1 minute left
                              logger.error("Lambda timeout approaching, cannot wait for build completion")
                              send_response(event, context, 'FAILED', {})
                              return

                          build_status = codebuild.batch_get_builds(ids=[build_id])
                          current_phase = build_status['builds'][0]['currentPhase']
                          build_complete = build_status['builds'][0]['buildComplete']

                          logger.info(f"Build status: {current_phase}, Complete: {build_complete}")

                          if build_complete:
                              final_status = build_status['builds'][0]['buildStatus']
                              logger.info(f"Build completed with status: {final_status}")

                              if final_status == 'SUCCEEDED':
                                  send_response(event, context, 'SUCCESS', {})
                                  return
                              else:
                                  send_response(event, context, 'FAILED', {})
                                  return

                          # Wait before checking again
                          time.sleep(wait_interval)
                          elapsed_time += wait_interval

                      # Timeout reached
                      send_response(event, context, 'FAILED', {})

                  elif request_type == 'Delete':
                      logger.info("Stack deletion - cleaning up resources")

                      # Clean up ECR repository
                      empty_ecr_repository(ecr_repository_name)

                      # Clean up OAuth2 credential provider
                      try:
                          identity_client = boto3.client("bedrock-agentcore-control",)
                          identity_client.delete_oauth2_credential_provider(name=provider_name)
                          logger.info(f"OAuth2 credential provider deleted: {provider_name}")
                      except Exception as e:
                          logger.error(f"Failed to delete OAuth2 credential provider: {str(e)}")
                          # Continue with deletion even if provider cleanup fails

                      send_response(event, context, 'SUCCESS', {})

                  elif request_type == 'Update':
                      logger.info("Stack update - no action required")
                      send_response(event, context, 'SUCCESS', {})

              except Exception as e:
                  logger.error(f"Error: {str(e)}")
                  send_response(event, context, 'FAILED', {})

          def send_response(event, context, response_status, response_data):
              response_body = {
                  'Status': response_status,
                  'Reason': 'See CloudWatch Logs',
                  'PhysicalResourceId': 'CodeBuildTrigger',
                  'StackId': event['StackId'],
                  'RequestId': event['RequestId'],
                  'LogicalResourceId': event['LogicalResourceId'],
                  # 'Data': response_data
              }

              json_response_body = json.dumps(response_body)

              headers = {
                  'content-type': '',
                  'content-length': str(len(json_response_body))
              }

              http = urllib3.PoolManager()
              response = http.request('PUT', event['ResponseURL'], body=json_response_body, headers=headers)
              logger.info(f"Response status: {response.status}")

  # Custom Resource to Trigger CodeBuild on Stack Creation
  CodeBuildTrigger:
    Type: AWS::CloudFormation::CustomResource
    DependsOn: AgentDockerBuildProject
    Properties:
      ServiceToken: !GetAtt CodeBuildTriggerFunction.Arn
      ProviderName: !Sub 'AgentOAuth2Provider-csvpc-${Environment}'

  # BedrockAgentCore Runtime using build-1 ECR image (first build from CodeBuildTrigger)
  AgentRuntime:
    Type: AWS::BedrockAgentCore::Runtime
    DependsOn: CodeBuildTrigger
    Properties:
      AgentRuntimeName: 'csvpcAgentRuntime'
      RoleArn: !GetAtt AgentCoreRuntimeExecutionRole.Arn
      NetworkConfiguration:
        NetworkMode: "VPC"
        NetworkModeConfig:
          SecurityGroups: 
            - Fn::ImportValue: !Sub '${VPCStackName}-AgentRuntimeSecurityGroup'
          Subnets: 
            - Fn::ImportValue: !Sub '${VPCStackName}-PrivateSubnet1'
      AgentRuntimeArtifact:
        ContainerConfiguration:
          ContainerUri: !Sub '${AWS::AccountId}.dkr.ecr.${AWS::Region}.amazonaws.com/${AgentECRRepository}:build-1'
      ProtocolConfiguration: HTTP
      AuthorizerConfiguration:
        CustomJWTAuthorizer:
          DiscoveryUrl: !Sub
            - 'https://cognito-idp.${AWS::Region}.amazonaws.com/${UserPoolId}/.well-known/openid-configuration'
            - UserPoolId:
                Fn::ImportValue: !Sub '${CognitoStackName}-UserPoolId'
          AllowedClients:
            - Fn::ImportValue: !Sub '${CognitoStackName}-WebUserPoolClientId'
      EnvironmentVariables:
        MODEL_ID: !Ref ModelID
        MCP_REGION: !Sub '${AWS::Region}'
        MCP_ARN:
          Fn::ImportValue: !Sub '${MCPStackName}-MCPDynamoDBRuntimeArn'
        MCP_PROVIDER_NAME: !Sub 'MCPOAuth2Provider-csvpc-${Environment}'
        GATEWAY_PROVIDER_NAME: !Sub 'GatewayOAuth2Provider-csvpc-${Environment}'
        AURORA_CLUSTER_ARN:
          Fn::ImportValue: !Sub '${AuroraStackName}-ClusterArn'
        AURORA_SECRET_ARN:
          Fn::ImportValue: !Sub '${AuroraStackName}-DBCredentialsSecret'
        AURORA_DATABASE:
          Fn::ImportValue: !Sub '${AuroraStackName}-DatabaseName'
      Tags:
        Name: !Sub 'csvpc-${Environment}-Agent-Runtime'
        Purpose: 'AgentCore Runtime'

  AgentRuntimeLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupClass: STANDARD
      LogGroupName: !Sub "/aws/vendedlogs/bedrock-agentcore/${AgentRuntime.AgentRuntimeId}"

  AgentRuntimeDeliverSourceApplicationLogs:
    Type: AWS::Logs::DeliverySource
    Properties:
      LogType: APPLICATION_LOGS
      Name: !Sub "${AgentRuntime.AgentRuntimeId}-logs-source"
      ResourceArn: !GetAtt AgentRuntime.AgentRuntimeArn

  AgentRuntimeDeliveryDestination:
    Type: AWS::Logs::DeliveryDestination
    Properties:
      DeliveryDestinationType: "CWL"
      DestinationResourceArn: !GetAtt AgentRuntimeLogGroup.Arn
      Name: !Sub "${AgentRuntime.AgentRuntimeId}-logs-destination"

  AgentRuntimeDeliveryApplicationLogs:
    Type: AWS::Logs::Delivery
    Properties:
      DeliveryDestinationArn: !GetAtt AgentRuntimeDeliveryDestination.Arn
      DeliverySourceName: !Sub "${AgentRuntime.AgentRuntimeId}-logs-source"

  # Lambda Execution Role for X-Ray Traces Setup
  XRayTracesSetupLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: CloudWatchLogsDeliveryPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - logs:PutDeliverySource
                  - logs:DeleteDeliverySource
                  - logs:PutDeliveryDestination
                  - logs:DeleteDeliveryDestination
                  - logs:CreateDelivery
                  - logs:DeleteDelivery
                  - logs:GetDeliverySource
                  - logs:GetDeliveryDestination
                  - logs:GetDelivery
                  - logs:DescribeDeliveries
                  - logs:DescribeDeliveryDestinations
                  - logs:DescribeDeliverySources
                  - logs:PutSubscriptionFilter
                  - logs:GetSubscriptionFilter
                  - logs:DeleteSubscriptionFilter
                  - logs:PutDeliveryDestinationPolicy
                  - logs:GetDeliveryDestinationPolicy
                  - logs:DeleteDeliveryDestinationPolicy
                Resource: '*'
        - PolicyName: AgentCoreDeliveryPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - bedrock-agentcore:AllowVendedLogDeliveryForResource
                Resource: '*'
        - PolicyName: XRayAccessPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - xray:PutTraceSegments
                  - xray:PutTelemetryRecords
                  - xray:GetSamplingRules
                  - xray:GetSamplingTargets
                  - xray:GetSamplingStatisticSummaries
                  - xray:PutResourcePolicy
                  - xray:ListResourcePolicies
                Resource: '*'
        - PolicyName: IAMPassRolePolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - iam:PassRole
                Resource: '*'
                Condition:
                  StringEquals:
                    'iam:PassedToService': 'logs.amazonaws.com'
      Tags:
        - Key: Name
          Value: !Sub 'csvpc-${Environment}-XRay-Traces-Setup-Role'
        - Key: Purpose
          Value: 'X-Ray Traces Setup Lambda'

  # Lambda Function for X-Ray Traces Setup
  XRayTracesSetupFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub 'csvpc-${Environment}-agent-xray-traces-setup'
      Runtime: python3.12
      Handler: index.lambda_handler
      Role: !GetAtt XRayTracesSetupLambdaRole.Arn
      Timeout: 300
      Environment:
        Variables:
          REGION: !Ref AWS::Region
          RESOURCE_ID: !GetAtt AgentRuntime.AgentRuntimeId
          RESOURCE_ARN: !GetAtt AgentRuntime.AgentRuntimeArn
      Code:
        ZipFile: |
          import json
          import boto3
          import urllib3
          import logging
          import os

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          def lambda_handler(event, context):
              try:
                  logger.info(f"Received event: {json.dumps(event)}")

                  request_type = event['RequestType']
                  region = os.environ['REGION']
                  resource_id = os.environ['RESOURCE_ID']
                  resource_arn = os.environ['RESOURCE_ARN']

                  logs_client = boto3.client('logs', region_name=region)

                  if request_type == 'Create':
                      logger.info("Setting up X-Ray traces delivery")

                      # Create delivery source for traces
                      traces_source_response = logs_client.put_delivery_source(
                          name=f"{resource_id}-traces-source",
                          logType="TRACES",
                          resourceArn=resource_arn
                      )
                      logger.info(f"Created delivery source: {traces_source_response['deliverySource']['name']}")

                      # Set delivery destination in XRAY
                      traces_destination_response = logs_client.put_delivery_destination(
                          name=f"{resource_id}-traces-destination",
                          deliveryDestinationType='XRAY'
                      )
                      logger.info(f"Created delivery destination: {traces_destination_response['deliveryDestination']['name']}")

                      # Create delivery
                      traces_delivery = logs_client.create_delivery(
                          deliverySourceName=traces_source_response['deliverySource']['name'],
                          deliveryDestinationArn=traces_destination_response['deliveryDestination']['arn']
                      )
                      logger.info(f"Created delivery: {traces_delivery['delivery']['id']}")

                      send_response(event, context, 'SUCCESS', {
                          'DeliveryId': traces_delivery['delivery']['id']
                      })

                  elif request_type == 'Delete':
                      logger.info("Cleaning up X-Ray traces delivery resources")

                      try:
                          # Delete delivery first
                          try:
                              logs_client.delete_delivery(
                                  id=f"{resource_id}-traces-source"
                              )
                              logger.info(f"Deleted delivery")
                          except logs_client.exceptions.ResourceNotFoundException:
                              logger.info("Delivery not found, skipping")
                          except Exception as e:
                              logger.warning(f"Error deleting delivery: {str(e)}")

                          # Delete delivery destination
                          try:
                              logs_client.delete_delivery_destination(
                                  name=f"{resource_id}-traces-destination"
                              )
                              logger.info(f"Deleted delivery destination")
                          except logs_client.exceptions.ResourceNotFoundException:
                              logger.info("Delivery destination not found, skipping")
                          except Exception as e:
                              logger.warning(f"Error deleting delivery destination: {str(e)}")

                          # Delete delivery source
                          try:
                              logs_client.delete_delivery_source(
                                  name=f"{resource_id}-traces-source"
                              )
                              logger.info(f"Deleted delivery source")
                          except logs_client.exceptions.ResourceNotFoundException:
                              logger.info("Delivery source not found, skipping")
                          except Exception as e:
                              logger.warning(f"Error deleting delivery source: {str(e)}")

                      except Exception as e:
                          logger.error(f"Error during cleanup: {str(e)}")
                          # Continue with SUCCESS to allow stack deletion

                      send_response(event, context, 'SUCCESS', {})

                  elif request_type == 'Update':
                      logger.info("Stack update - no action required")
                      send_response(event, context, 'SUCCESS', {})

              except Exception as e:
                  logger.error(f"Error: {str(e)}", exc_info=True)
                  send_response(event, context, 'FAILED', {})

          def send_response(event, context, response_status, response_data):
              response_body = {
                  'Status': response_status,
                  'Reason': 'See CloudWatch Logs',
                  'PhysicalResourceId': 'XRayTracesSetup',
                  'StackId': event['StackId'],
                  'RequestId': event['RequestId'],
                  'LogicalResourceId': event['LogicalResourceId'],
                  'Data': response_data
              }

              json_response_body = json.dumps(response_body)

              headers = {
                  'content-type': '',
                  'content-length': str(len(json_response_body))
              }

              http = urllib3.PoolManager()
              response = http.request('PUT', event['ResponseURL'], body=json_response_body, headers=headers)
              logger.info(f"Response status: {response.status}")
      Tags:
        - Key: Name
          Value: !Sub 'csvpc-${Environment}-XRay-Traces-Setup-Function'

  # Custom Resource to Setup X-Ray Traces
  XRayTracesSetup:
    Type: AWS::CloudFormation::CustomResource
    DependsOn: AgentRuntime
    Properties:
      ServiceToken: !GetAtt XRayTracesSetupFunction.Arn

  # SSM Parameter for Agent Runtime ARN
  AgentRuntimeArnParameter:
    Type: AWS::SSM::Parameter
    Properties:
      Name: /app/customersupportvpc/agentcore/agent_runtime_arn
      Type: String
      Value: !GetAtt AgentRuntime.AgentRuntimeArn
      Description: Agent Runtime ARN
      Tags:
        Application: CustomerSupportVPC

Outputs:
  AgentRuntimeArn:
    Description: 'ARN of the BedrockAgentCore Runtime'
    Value: !GetAtt AgentRuntime.AgentRuntimeArn
    Export:
      Name: !Sub '${AWS::StackName}-AgentRuntimeArn'

  AgentRuntimeId:
    Description: 'ID of the BedrockAgentCore Runtime'
    Value: !GetAtt AgentRuntime.AgentRuntimeId
    Export:
      Name: !Sub '${AWS::StackName}-AgentRuntimeId'

  AgentRuntimeName:
    Description: 'Name of the BedrockAgentCore Runtime'
    Value: !Ref AgentRuntime
    Export:
      Name: !Sub '${AWS::StackName}-AgentRuntimeName'
  
  AgentProviderName: 
    Description: 'Name of the Agent provider'
    Value: !Sub 'AgentOAuth2Provider-csvpc-${Environment}'
    Export:
      Name: !Sub '${AWS::StackName}-AgentProviderName'
