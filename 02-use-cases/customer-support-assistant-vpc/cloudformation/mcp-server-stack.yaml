AWSTemplateFormatVersion: '2010-09-09'
Description: 'Model Context Protocol (MCP) server for DynamoDB access. Deploys Bedrock AgentCore runtime with Docker image stored in ECR, OAuth2 authentication, and automated build pipeline via CodeBuild. Includes EventBridge-triggered updates on new image pushes.'


Metadata:
  'AWS::CloudFormation::Interface':
    ParameterGroups:
    - Label:
        default: 'Environment Configuration'
      Parameters:
      - Environment
    - Label:
        default: 'Stack References'
      Parameters:
      - VPCStackName
      - CognitoStackName
      - DynamoDBStackName

Parameters:
  Environment:
    Type: String
    Default: 'dev'
    AllowedValues:
      - dev
      - test
      - prod
    Description: 'Environment name for resource naming'

  VPCStackName:
    Type: String
    Description: 'Name of the VPC stack to reference for network configuration'

  CognitoStackName:
    Type: String
    Description: 'Name of the Cognito stack to reference for client configuration'

  DynamoDBStackName:
    Type: String
    Description: 'Name of the DynamoDB stack to reference for table access'

Resources:
  # ECR Repository for MCP DynamoDB Docker Images
  MCPDynamoDBECRRepository:
    Type: AWS::ECR::Repository
    Properties:
      RepositoryName: !Sub 'csvpc-${Environment}-mcp-repository'
      ImageScanningConfiguration:
        ScanOnPush: true
      LifecyclePolicy:
        LifecyclePolicyText: |
          {
            "rules": [
              {
                "rulePriority": 1,
                "selection": {
                  "tagStatus": "untagged",
                  "countType": "sinceImagePushed",
                  "countUnit": "days",
                  "countNumber": 1
                },
                "action": {
                  "type": "expire"
                }
              },
              {
                "rulePriority": 2,
                "selection": {
                  "tagStatus": "tagged",
                  "tagPrefixList": ["v", "latest", "main", "master"],
                  "countType": "imageCountMoreThan",
                  "countNumber": 10
                },
                "action": {
                  "type": "expire"
                }
              }
            ]
          }
      Tags:
        - Key: Name
          Value: !Sub 'csvpc-${Environment}-MCPDynamoDB-ECR'
        - Key: Purpose
          Value: 'MCP DynamoDB Docker Images'
    DeletionPolicy: Delete

  # MCP DynamoDB Runtime Execution Role
  MCPDynamoDBRuntimeExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub 'csvpc-${Environment}-mcp-runtime-execution-role'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Sid: AssumeRolePolicy
            Effect: Allow
            Principal:
              Service: bedrock-agentcore.amazonaws.com
            Action: sts:AssumeRole
            Condition:
              StringEquals:
                'aws:SourceAccount': !Ref AWS::AccountId
              ArnLike:
                'aws:SourceArn': !Sub 'arn:aws:bedrock-agentcore:${AWS::Region}:${AWS::AccountId}:*'
      Policies:
        - PolicyName: MCPDynamoDBRuntimeExecutionPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Sid: ECRImageAccess
                Effect: Allow
                Action:
                  - ecr:BatchGetImage
                  - ecr:GetDownloadUrlForLayer
                Resource:
                  - !Sub 'arn:aws:ecr:${AWS::Region}:${AWS::AccountId}:repository/*'
              - Effect: Allow
                Action:
                  - logs:DescribeLogStreams
                  - logs:CreateLogGroup
                Resource:
                  - !Sub 'arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/bedrock-agentcore/runtimes/*'
              - Effect: Allow
                Action:
                  - logs:DescribeLogGroups
                Resource:
                  - !Sub 'arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:*'
              - Effect: Allow
                Action:
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource:
                  - !Sub 'arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/bedrock-agentcore/runtimes/*:log-stream:*'
              - Sid: ECRTokenAccess
                Effect: Allow
                Action:
                  - ecr:GetAuthorizationToken
                Resource: '*'
              - Effect: Allow
                Action:
                  - xray:PutTraceSegments
                  - xray:PutTelemetryRecords
                  - xray:GetSamplingRules
                  - xray:GetSamplingTargets
                Resource: '*'
              - Effect: Allow
                Resource: '*'
                Action: cloudwatch:PutMetricData
                Condition:
                  StringEquals:
                    'cloudwatch:namespace': 'bedrock-agentcore'
              - Sid: GetMCPAccessToken
                Effect: Allow
                Action:
                  - bedrock-agentcore:GetWorkloadAccessToken
                  - bedrock-agentcore:GetWorkloadAccessTokenForJWT
                  - bedrock-agentcore:GetWorkloadAccessTokenForUserId
                Resource:
                  - !Sub 'arn:aws:bedrock-agentcore:${AWS::Region}:${AWS::AccountId}:workload-identity-directory/default'
                  - !Sub 'arn:aws:bedrock-agentcore:${AWS::Region}:${AWS::AccountId}:workload-identity-directory/default/workload-identity/csvpcMCPDynamoDBRuntime*'
              - Sid: DynamoDBAccess
                Effect: Allow
                Action:
                  - dynamodb:GetItem
                  - dynamodb:PutItem
                  - dynamodb:UpdateItem
                  - dynamodb:DeleteItem
                  - dynamodb:Query
                  - dynamodb:Scan
                  - dynamodb:DescribeTable
                Resource:
                  - Fn::ImportValue: !Sub '${DynamoDBStackName}-ReviewsTableArn'
                  - Fn::ImportValue: !Sub '${DynamoDBStackName}-ProductsTableArn'
                  - !Sub
                    - '${ReviewsTableArn}/index/*'
                    - ReviewsTableArn:
                        Fn::ImportValue: !Sub '${DynamoDBStackName}-ReviewsTableArn'
                  - !Sub
                    - '${ProductsTableArn}/index/*'
                    - ProductsTableArn:
                        Fn::ImportValue: !Sub '${DynamoDBStackName}-ProductsTableArn'
              - Sid: DynamoDBListAccess
                Effect: Allow
                Action:
                  - dynamodb:ListTables
                Resource: '*'
              - Sid: KMSAccess
                Effect: Allow
                Action:
                  - kms:Decrypt
                  - kms:GenerateDataKey
                  - kms:DescribeKey
                Resource:
                  - Fn::ImportValue: !Sub '${DynamoDBStackName}-DynamoDBKMSKey'
              - Sid: SSMParameterAccess
                Effect: Allow
                Action:
                  - ssm:GetParameter
                  - ssm:GetParameters
                Resource:
                  - !Sub 'arn:aws:ssm:${AWS::Region}:${AWS::AccountId}:parameter/app/customersupportvpc/dynamodb/reviews_table_name'
                  - !Sub 'arn:aws:ssm:${AWS::Region}:${AWS::AccountId}:parameter/app/customersupportvpc/dynamodb/products_table_name'
      Tags:
        - Key: Name
          Value: !Sub 'csvpc-${Environment}-MCPDynamoDB-Runtime-Role'
        - Key: Purpose
          Value: 'MCP DynamoDB Runtime Execution'

  # CodeBuild Service Role for Docker Image Build
  CodeBuildServiceRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: codebuild.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: CodeBuildLogsPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource:
                  - "*"
        - PolicyName: ECRAccessPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - ecr:BatchCheckLayerAvailability
                  - ecr:GetDownloadUrlForLayer
                  - ecr:BatchGetImage
                  - ecr:GetAuthorizationToken
                Resource: '*'
              - Effect: Allow
                Action:
                  - ecr:InitiateLayerUpload
                  - ecr:UploadLayerPart
                  - ecr:CompleteLayerUpload
                  - ecr:PutImage
                Resource: !GetAtt MCPDynamoDBECRRepository.Arn
      Tags:
        - Key: Name
          Value: !Sub 'csvpc-${Environment}-CodeBuild-Role'
        - Key: Purpose
          Value: 'CodeBuild Docker Image Build'

  # CodeBuild Project for MCP DynamoDB Docker Image
  MCPDynamoDBDockerBuildProject:
    Type: AWS::CodeBuild::Project
    Properties:
      Name: !Sub 'csvpc-${Environment}-mcp-docker-build'
      Description: 'Build and push MCP DynamoDB Docker image to ECR'
      ServiceRole: !GetAtt CodeBuildServiceRole.Arn
      Artifacts:
        Type: NO_ARTIFACTS
      Environment:
        Type: ARM_CONTAINER
        ComputeType: BUILD_GENERAL1_LARGE
        Image: aws/codebuild/amazonlinux2-aarch64-standard:3.0
        PrivilegedMode: true
        EnvironmentVariables:
          - Name: ECR_REPOSITORY_URI
            Value: !Sub '${AWS::AccountId}.dkr.ecr.${AWS::Region}.amazonaws.com/${MCPDynamoDBECRRepository}'
          - Name: ECR_REPOSITORY_NAME
            Value: !Ref MCPDynamoDBECRRepository
          - Name: AWS_DEFAULT_REGION
            Value: !Ref AWS::Region
          - Name: AWS_ACCOUNT_ID
            Value: !Ref AWS::AccountId
      Source:
        Type: GITHUB
        Location: 'https://github.com/awslabs/amazon-bedrock-agentcore-samples.git'
        GitCloneDepth: 1
        BuildSpec: |
          version: 0.2
          phases:
            pre_build:
              commands:
                - echo "Checking current directory and contents..."
                - pwd
                - ls -la
                - echo "Navigating to MCP DynamoDB directory..."
                - cd 02-use-cases/customer-support-assistant-vpc/mcp_dynamodb
                - echo "Contents of mcp_dynamodb directory:"
                - ls -la
                - echo "Checking for Dockerfile..."
                - cat Dockerfile || echo "Dockerfile not found"
                - echo "Generating unique image tag..."
                - export IMAGE_TAG="build-${CODEBUILD_BUILD_NUMBER}"
                - echo "Image will be tagged as ${IMAGE_TAG}"
            build:
              commands:
                - echo "Starting parallel Docker build and ECR authentication..."
                - |
                  docker build -t bedrock-agentcore-arm64 . &
                  BUILD_PID=$!
                  aws ecr get-login-password --region $AWS_DEFAULT_REGION | \
                  docker login --username AWS --password-stdin $ECR_REPOSITORY_URI &
                  AUTH_PID=$!
                  echo "Waiting for Docker build to complete..."
                  wait $BUILD_PID
                  if [ $? -ne 0 ]; then
                    echo "Docker build failed"
                    exit 1
                  fi
                  echo "Waiting for ECR authentication to complete..."
                  wait $AUTH_PID
                  if [ $? -ne 0 ]; then
                    echo "ECR authentication failed"
                    exit 1
                  fi
                  echo "Both build and auth completed successfully"
                - echo "Tagging image with unique tag ${IMAGE_TAG}..."
                - docker tag bedrock-agentcore-arm64:latest $ECR_REPOSITORY_URI:${IMAGE_TAG}
            post_build:
              commands:
                - echo "Pushing ARM64 image to ECR with unique tag ${IMAGE_TAG}..."
                - docker push $ECR_REPOSITORY_URI:${IMAGE_TAG}
                - echo "Build completed at $(date)"
                - echo "Image tag pushed - ${IMAGE_TAG}"
      TimeoutInMinutes: 30
      Tags:
        - Key: Name
          Value: !Sub 'csvpc-${Environment}-MCPDynamoDB-Docker-Build'
        - Key: Purpose
          Value: 'MCP DynamoDB Docker Image Build'

  # Lambda Execution Role for ECR Image Notification
  ECRImageNotificationLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: ECRAccessPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - ecr:DescribeImages
                  - ecr:ListImages
                Resource: !GetAtt MCPDynamoDBECRRepository.Arn
        - PolicyName: BedrockAgentCoreAccessPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - bedrock-agentcore:ListAgentRuntimes
                  - bedrock-agentcore:ListAgentRuntimeEndpoints
                  - bedrock-agentcore:ListAgentRuntimeVersions
                  - bedrock-agentcore:GetAgentRuntime
                  - bedrock-agentcore:GetAgentRuntimeEndpoint
                  - bedrock-agentcore:UpdateAgentRuntime
                  - bedrock-agentcore:UpdateAgentRuntimeEndpoint
                Resource: '*'
        - PolicyName: IAMPassRole
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - iam:PassRole
                Resource: !GetAtt MCPDynamoDBRuntimeExecutionRole.Arn
      Tags:
        - Key: Name
          Value: !Sub 'csvpc-${Environment}-ECR-Notification-Role'
        - Key: Purpose
          Value: 'ECR Image Notification Lambda'

  # Lambda Function for ECR Image Notification
  ECRImageNotificationFunction:
    Type: AWS::Lambda::Function
    DependsOn: MCPDynamoDBRuntime
    Properties:
      FunctionName: !Sub 'csvpc-${Environment}-mcp-ecr-notification'
      Runtime: python3.12
      Handler: index.lambda_handler
      Role: !GetAtt ECRImageNotificationLambdaRole.Arn
      Timeout: 300
      Environment:
        Variables:
          AGENT_RUNTIME_ID: !GetAtt MCPDynamoDBRuntime.AgentRuntimeId
          ECR_REPOSITORY_URI: !Sub '${AWS::AccountId}.dkr.ecr.${AWS::Region}.amazonaws.com/${MCPDynamoDBECRRepository}'
          ROLE_ARN: !GetAtt MCPDynamoDBRuntimeExecutionRole.Arn
      Code:
        ZipFile: |
          import json
          import logging
          import boto3
          import os

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          def lambda_handler(event, context):
              try:
                  logger.info(f"Received ECR event: {json.dumps(event)}")

                  # Parse the ECR event
                  detail = event.get('detail', {})
                  repository_name = detail.get('repository-name')
                  image_tag = detail.get('image-tag', 'latest')
                  action = detail.get('action-type')
                  result = detail.get('result')

                  logger.info(f"ECR Event - Repository: {repository_name}, Tag: {image_tag}, Action: {action}, Result: {result}")

                  # Only proceed if the push was successful
                  if action != 'PUSH' or result != 'SUCCESS':
                      logger.info("Skipping non-push or failed event")
                      return {
                          'statusCode': 200,
                          'body': json.dumps('Event skipped - not a successful push')
                      }

                  # Get environment variables
                  agent_runtime_id = os.environ['AGENT_RUNTIME_ID']
                  ecr_repository_uri = os.environ['ECR_REPOSITORY_URI']
                  role_arn = os.environ['ROLE_ARN']

                  # Initialize bedrock-agentcore-control client
                  client = boto3.client('bedrock-agentcore-control')

                  # Get current runtime configuration
                  logger.info(f"Getting current runtime configuration for: {agent_runtime_id}")
                  get_response = client.get_agent_runtime(agentRuntimeId=agent_runtime_id)

                  logger.info(f"Current runtime status: {get_response}")

                  # Build new container URI with the pushed image tag
                  new_container_uri = f"{ecr_repository_uri}:{image_tag}"

                  logger.info(f"Updating runtime to use new container: {new_container_uri}")

                  # Update the runtime with the new container image
                  update_response = client.update_agent_runtime(
                      agentRuntimeId=agent_runtime_id,
                      agentRuntimeArtifact={
                          'containerConfiguration': {
                              'containerUri': new_container_uri
                          }
                      },
                      roleArn=role_arn,
                      networkConfiguration=get_response['networkConfiguration'],
                      protocolConfiguration=get_response['protocolConfiguration'],
                      authorizerConfiguration=get_response['authorizerConfiguration'],
                  )

                  logger.info(f"Runtime updated successfully. New version: {update_response['agentRuntimeVersion']}")

                  return {
                      'statusCode': 200,
                      'body': json.dumps({
                          'message': 'AgentCore Runtime updated successfully',
                          'newContainerUri': new_container_uri,
                          'runtimeId': agent_runtime_id,
                          'newVersion': update_response['agentRuntimeVersion']
                      })
                  }

              except Exception as e:
                  logger.error(f"Error processing ECR event: {str(e)}", exc_info=True)
                  return {
                      'statusCode': 500,
                      'body': json.dumps({'error': str(e)})
                  }
      Tags:
        - Key: Name
          Value: !Sub 'csvpc-${Environment}-ECR-Notification-Function'

  # EventBridge Permission for Lambda
  ECRImageNotificationLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref ECRImageNotificationFunction
      Action: lambda:InvokeFunction
      Principal: events.amazonaws.com
      SourceArn: !GetAtt ECRImageEventRule.Arn

  # EventBridge Rule for ECR Image Push
  ECRImageEventRule:
    Type: AWS::Events::Rule
    Properties:
      Name: !Sub 'csvpc-${Environment}-mcp-ecr-push-rule'
      Description: 'Trigger Lambda when new ECR image is pushed'
      EventPattern:
        source:
          - aws.ecr
        detail-type:
          - ECR Image Action
        detail:
          action-type:
            - PUSH
          result:
            - SUCCESS
          repository-name:
            - !Ref MCPDynamoDBECRRepository
      State: ENABLED
      Targets:
        - Arn: !GetAtt ECRImageNotificationFunction.Arn
          Id: ECRImageNotificationTarget

  # Lambda Execution Role for CodeBuild Trigger
  CodeBuildTriggerLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: CodeBuildTriggerPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - codebuild:StartBuild
                  - codebuild:BatchGetBuilds
                Resource: !GetAtt MCPDynamoDBDockerBuildProject.Arn
        - PolicyName: SecretsManagerAccessPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - secretsmanager:GetSecretValue
                Resource:
                  - Fn::ImportValue: !Sub '${CognitoStackName}-MCPClientSecret'
              - Effect: Allow
                Action:
                  - kms:Decrypt
                  - kms:GenerateDataKey
                Resource:
                  Fn::ImportValue: !Sub '${CognitoStackName}-SecretsManagerKMSKeyArn'
        - PolicyName: BedrockIdentityAccessPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - bedrock-agentcore:GetResourceOauth2Token
                  - bedrock-agentcore:CreateOauth2CredentialProvider
                  - bedrock-agentcore:DeleteOauth2CredentialProvider
                  - bedrock-agentcore:UpdateOauth2CredentialProvider
                  - bedrock-agentcore:ListOauth2CredentialProviders
                  - bedrock-agentcore:GetOauth2CredentialProvider
                Resource: '*'
              - Effect: Allow
                Action:
                  - secretsmanager:CreateSecret
                  - secretsmanager:DeleteSecret
                Resource: '*'
              - Effect: Allow
                Action:
                  - bedrock-agentcore:ListWorkloadIdentities
                  - bedrock-agentcore:UpdateWorkloadIdentity
                  - bedrock-agentcore:DeleteWorkloadIdentity
                  - bedrock-agentcore:CreateWorkloadIdentity
                Resource:
                  - !Sub 'arn:aws:bedrock-agentcore:${AWS::Region}:${AWS::AccountId}:workload-identity-directory/*/workload-identity/*'
                  - !Sub 'arn:aws:bedrock-agentcore:${AWS::Region}:${AWS::AccountId}:workload-identity-directory/*'
              - Effect: Allow
                Action:
                  - bedrock-agentcore:GetTokenVault
                  - bedrock-agentcore:CreateTokenVault
                  - bedrock-agentcore:DeleteTokenVault
                Resource: '*'
        - PolicyName: ECRCleanupPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - ecr:ListImages
                  - ecr:BatchDeleteImage
                Resource: !GetAtt MCPDynamoDBECRRepository.Arn
      Tags:
        - Key: Name
          Value: !Sub 'csvpc-${Environment}-CodeBuild-Trigger-Role'
        - Key: Purpose
          Value: 'CodeBuild Trigger Lambda'

  # Lambda Function to Trigger CodeBuild
  CodeBuildTriggerFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub 'csvpc-${Environment}-mcp-codebuild'
      Runtime: python3.12
      Handler: index.lambda_handler
      Role: !GetAtt CodeBuildTriggerLambdaRole.Arn
      Timeout: 900
      Environment:
        Variables:
          CODEBUILD_PROJECT_NAME: !Ref MCPDynamoDBDockerBuildProject
          MCP_CLIENT_SECRET_ARN:
            Fn::ImportValue: !Sub '${CognitoStackName}-MCPClientSecret'
          DISCOVERY_URL: !Sub
            - 'https://cognito-idp.${AWS::Region}.amazonaws.com/${UserPoolId}/.well-known/openid-configuration'
            - UserPoolId:
                Fn::ImportValue: !Sub '${CognitoStackName}-UserPoolId'
          ECR_REPOSITORY_NAME: !Ref MCPDynamoDBECRRepository
      Code:
        ZipFile: |
          import json
          import boto3
          import urllib3
          import logging
          import os
          import time

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          def create_oauth2_credential_provider(secret_arn, discovery_url, provider_name):
              try:
                  logger.info(f"Creating OAuth2 credential provider for MCP: {provider_name}")

                  # Get client credentials from Secrets Manager
                  secrets_client = boto3.client('secretsmanager')
                  secret_response = secrets_client.get_secret_value(SecretId=secret_arn)
                  secret_data = json.loads(secret_response['SecretString'])

                  client_id = secret_data['client_id']
                  client_secret = secret_data['client_secret']
                  token_url = secret_data['token_endpoint']
                  auth_url = discovery_url.replace('/.well-known/openid-configuration', '/oauth2/authorize')

                  # Create OAuth2 credential provider
                  identity_client = boto3.client("bedrock-agentcore-control",)

                  identity_client.create_oauth2_credential_provider(
                      name=provider_name,
                      credentialProviderVendor="CustomOauth2",
                      oauth2ProviderConfigInput={
                          "customOauth2ProviderConfig": {
                              "clientId": client_id,
                              "clientSecret": client_secret,
                              "oauthDiscovery": {
                                  "discoveryUrl": discovery_url
                              },
                          }
                      },
                  )

                  logger.info(f"OAuth2 credential provider created: {provider_name}")
                  return provider_name

              except Exception as e:
                  logger.error(f"Failed to create OAuth2 credential provider: {str(e)}")
                  raise e

          def empty_ecr_repository(repository_name):
              try:
                  logger.info(f"Emptying ECR repository: {repository_name}")

                  ecr_client = boto3.client('ecr')

                  # List all images in the repository
                  response = ecr_client.list_images(repositoryName=repository_name)

                  if not response['imageIds']:
                      logger.info("Repository is already empty")
                      return

                  # Delete all images
                  logger.info(f"Deleting {len(response['imageIds'])} images from repository")
                  ecr_client.batch_delete_image(
                      repositoryName=repository_name,
                      imageIds=response['imageIds']
                  )

                  logger.info(f"Successfully emptied ECR repository: {repository_name}")

              except Exception as e:
                  logger.error(f"Failed to empty ECR repository: {str(e)}")
                  # Don't raise the exception, as we want deletion to continue

          def lambda_handler(event, context):
              try:
                  logger.info(f"Received event: {json.dumps(event)}")

                  request_type = event['RequestType']
                  project_name = os.environ['CODEBUILD_PROJECT_NAME']
                  mcp_client_secret_arn = os.environ['MCP_CLIENT_SECRET_ARN']
                  discovery_url = os.environ['DISCOVERY_URL']
                  provider_name = event['ResourceProperties']['ProviderName']
                  ecr_repository_name = os.environ['ECR_REPOSITORY_NAME']

                  if request_type == 'Create':
                      # Create OAuth2 credential provider first
                      create_oauth2_credential_provider(mcp_client_secret_arn, discovery_url, provider_name)
                      # Start CodeBuild project on stack creation and wait for completion
                      codebuild = boto3.client('codebuild')

                      logger.info(f"Starting CodeBuild project: {project_name}")

                      response = codebuild.start_build(projectName=project_name)
                      build_id = response['build']['id']

                      logger.info(f"Build started successfully with ID: {build_id}")

                      # Wait for build to complete
                      max_wait_time = 1800  # 30 minutes
                      wait_interval = 30    # 30 seconds
                      elapsed_time = 0

                      while elapsed_time < max_wait_time:
                          # Check remaining Lambda execution time
                          remaining_time = context.get_remaining_time_in_millis()
                          if remaining_time < 60000:  # Less than 1 minute left
                              logger.error("Lambda timeout approaching, cannot wait for build completion")
                              send_response(event, context, 'FAILED', {})
                              return

                          build_status = codebuild.batch_get_builds(ids=[build_id])
                          current_phase = build_status['builds'][0]['currentPhase']
                          build_complete = build_status['builds'][0]['buildComplete']

                          logger.info(f"Build status: {current_phase}, Complete: {build_complete}")

                          if build_complete:
                              final_status = build_status['builds'][0]['buildStatus']
                              logger.info(f"Build completed with status: {final_status}")

                              if final_status == 'SUCCEEDED':
                                  send_response(event, context, 'SUCCESS', {})
                                  return
                              else:
                                  send_response(event, context, 'FAILED', {})
                                  return

                          # Wait before checking again
                          time.sleep(wait_interval)
                          elapsed_time += wait_interval

                      # Timeout reached
                      send_response(event, context, 'FAILED', {})

                  elif request_type == 'Delete':
                      logger.info("Stack deletion - cleaning up resources")

                      # Clean up ECR repository
                      empty_ecr_repository(ecr_repository_name)

                      # Clean up OAuth2 credential provider
                      try:
                          identity_client = boto3.client("bedrock-agentcore-control",)
                          identity_client.delete_oauth2_credential_provider(name=provider_name)
                          logger.info(f"OAuth2 credential provider deleted: {provider_name}")
                      except Exception as e:
                          logger.error(f"Failed to delete OAuth2 credential provider: {str(e)}")
                          # Continue with deletion even if provider cleanup fails

                      send_response(event, context, 'SUCCESS', {})

                  elif request_type == 'Update':
                      logger.info("Stack update - no action required")
                      send_response(event, context, 'SUCCESS', {})

              except Exception as e:
                  logger.error(f"Error: {str(e)}")
                  send_response(event, context, 'FAILED', {})

          def send_response(event, context, response_status, response_data):
              response_body = {
                  'Status': response_status,
                  'Reason': 'See CloudWatch Logs',
                  'PhysicalResourceId': 'CodeBuildTrigger',
                  'StackId': event['StackId'],
                  'RequestId': event['RequestId'],
                  'LogicalResourceId': event['LogicalResourceId'],
                  # 'Data': response_data
              }

              json_response_body = json.dumps(response_body)

              headers = {
                  'content-type': '',
                  'content-length': str(len(json_response_body))
              }

              http = urllib3.PoolManager()
              response = http.request('PUT', event['ResponseURL'], body=json_response_body, headers=headers)
              logger.info(f"Response status: {response.status}")

  # Custom Resource to Trigger CodeBuild on Stack Creation
  CodeBuildTrigger:
    Type: AWS::CloudFormation::CustomResource
    DependsOn: MCPDynamoDBDockerBuildProject
    Properties:
      ServiceToken: !GetAtt CodeBuildTriggerFunction.Arn
      ProviderName: !Sub 'MCPOAuth2Provider-csvpc-${Environment}'

  # BedrockAgentCore Runtime using latest ECR image
  MCPDynamoDBRuntime:
    Type: AWS::BedrockAgentCore::Runtime
    DependsOn: CodeBuildTrigger
    Properties:
      AgentRuntimeName: 'csvpcMCPDynamoDBRuntime'
      RoleArn: !GetAtt MCPDynamoDBRuntimeExecutionRole.Arn
      NetworkConfiguration:
        NetworkMode: "VPC"
        NetworkModeConfig:
          SecurityGroups: 
            - Fn::ImportValue: !Sub '${VPCStackName}-MCPRuntimeSecurityGroup'
          Subnets: 
            - Fn::ImportValue: !Sub '${VPCStackName}-PrivateSubnet3'
      AgentRuntimeArtifact:
        ContainerConfiguration:
          ContainerUri: !Sub '${AWS::AccountId}.dkr.ecr.${AWS::Region}.amazonaws.com/${MCPDynamoDBECRRepository}:build-1'
      ProtocolConfiguration: MCP
      AuthorizerConfiguration:
        CustomJWTAuthorizer:
          DiscoveryUrl: !Sub
            - 'https://cognito-idp.${AWS::Region}.amazonaws.com/${UserPoolId}/.well-known/openid-configuration'
            - UserPoolId:
                Fn::ImportValue: !Sub '${CognitoStackName}-UserPoolId'
          AllowedClients:
            - Fn::ImportValue: !Sub '${CognitoStackName}-MCPClientId'
      Tags:
        Name: !Sub 'csvpc-${Environment}-MCPDynamoDB-Runtime'
        Purpose: 'MCP DynamoDB Runtime'

  # Lambda Execution Role for X-Ray Traces Setup
  XRayTracesSetupLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: CloudWatchLogsDeliveryPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - logs:PutDeliverySource
                  - logs:DeleteDeliverySource
                  - logs:PutDeliveryDestination
                  - logs:DeleteDeliveryDestination
                  - logs:CreateDelivery
                  - logs:DeleteDelivery
                  - logs:GetDeliverySource
                  - logs:GetDeliveryDestination
                  - logs:GetDelivery
                  - logs:DescribeDeliveries
                  - logs:DescribeDeliveryDestinations
                  - logs:DescribeDeliverySources
                  - logs:PutSubscriptionFilter
                  - logs:GetSubscriptionFilter
                  - logs:DeleteSubscriptionFilter
                  - logs:PutDeliveryDestinationPolicy
                  - logs:GetDeliveryDestinationPolicy
                  - logs:DeleteDeliveryDestinationPolicy
                Resource: '*'
        - PolicyName: AgentCoreDeliveryPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - bedrock-agentcore:AllowVendedLogDeliveryForResource
                Resource: '*'
        - PolicyName: XRayAccessPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - xray:PutTraceSegments
                  - xray:PutTelemetryRecords
                  - xray:GetSamplingRules
                  - xray:GetSamplingTargets
                  - xray:GetSamplingStatisticSummaries
                  - xray:PutResourcePolicy
                  - xray:ListResourcePolicies
                Resource: '*'
        - PolicyName: IAMPassRolePolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - iam:PassRole
                Resource: '*'
                Condition:
                  StringEquals:
                    'iam:PassedToService': 'logs.amazonaws.com'
      Tags:
        - Key: Name
          Value: !Sub 'csvpc-${Environment}-XRay-Traces-Setup-Role'
        - Key: Purpose
          Value: 'X-Ray Traces Setup Lambda'

  # Lambda Function for X-Ray Traces Setup
  XRayTracesSetupFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub 'csvpc-${Environment}-mcp-dynamodb-xray-traces-setup'
      Runtime: python3.12
      Handler: index.lambda_handler
      Role: !GetAtt XRayTracesSetupLambdaRole.Arn
      Timeout: 300
      Environment:
        Variables:
          REGION: !Ref AWS::Region
          RESOURCE_ID: !GetAtt MCPDynamoDBRuntime.AgentRuntimeId
          RESOURCE_ARN: !GetAtt MCPDynamoDBRuntime.AgentRuntimeArn
      Code:
        ZipFile: |
          import json
          import boto3
          import urllib3
          import logging
          import os

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          def lambda_handler(event, context):
              try:
                  logger.info(f"Received event: {json.dumps(event)}")

                  request_type = event['RequestType']
                  region = os.environ['REGION']
                  resource_id = os.environ['RESOURCE_ID']
                  resource_arn = os.environ['RESOURCE_ARN']

                  logs_client = boto3.client('logs', region_name=region)

                  if request_type == 'Create':
                      logger.info("Setting up X-Ray traces delivery")

                      # Create delivery source for traces
                      traces_source_response = logs_client.put_delivery_source(
                          name=f"{resource_id}-traces-source",
                          logType="TRACES",
                          resourceArn=resource_arn
                      )
                      logger.info(f"Created delivery source: {traces_source_response['deliverySource']['name']}")

                      # Set delivery destination in XRAY
                      traces_destination_response = logs_client.put_delivery_destination(
                          name=f"{resource_id}-traces-destination",
                          deliveryDestinationType='XRAY'
                      )
                      logger.info(f"Created delivery destination: {traces_destination_response['deliveryDestination']['name']}")

                      # Create delivery
                      traces_delivery = logs_client.create_delivery(
                          deliverySourceName=traces_source_response['deliverySource']['name'],
                          deliveryDestinationArn=traces_destination_response['deliveryDestination']['arn']
                      )
                      logger.info(f"Created delivery: {traces_delivery['delivery']['id']}")

                      send_response(event, context, 'SUCCESS', {
                          'DeliveryId': traces_delivery['delivery']['id']
                      })

                  elif request_type == 'Delete':
                      logger.info("Cleaning up X-Ray traces delivery resources")

                      try:
                          # Delete delivery first
                          try:
                              logs_client.delete_delivery(
                                  id=f"{resource_id}-traces-source"
                              )
                              logger.info(f"Deleted delivery")
                          except logs_client.exceptions.ResourceNotFoundException:
                              logger.info("Delivery not found, skipping")
                          except Exception as e:
                              logger.warning(f"Error deleting delivery: {str(e)}")

                          # Delete delivery destination
                          try:
                              logs_client.delete_delivery_destination(
                                  name=f"{resource_id}-traces-destination"
                              )
                              logger.info(f"Deleted delivery destination")
                          except logs_client.exceptions.ResourceNotFoundException:
                              logger.info("Delivery destination not found, skipping")
                          except Exception as e:
                              logger.warning(f"Error deleting delivery destination: {str(e)}")

                          # Delete delivery source
                          try:
                              logs_client.delete_delivery_source(
                                  name=f"{resource_id}-traces-source"
                              )
                              logger.info(f"Deleted delivery source")
                          except logs_client.exceptions.ResourceNotFoundException:
                              logger.info("Delivery source not found, skipping")
                          except Exception as e:
                              logger.warning(f"Error deleting delivery source: {str(e)}")

                      except Exception as e:
                          logger.error(f"Error during cleanup: {str(e)}")
                          # Continue with SUCCESS to allow stack deletion

                      send_response(event, context, 'SUCCESS', {})

                  elif request_type == 'Update':
                      logger.info("Stack update - no action required")
                      send_response(event, context, 'SUCCESS', {})

              except Exception as e:
                  logger.error(f"Error: {str(e)}", exc_info=True)
                  send_response(event, context, 'FAILED', {})

          def send_response(event, context, response_status, response_data):
              response_body = {
                  'Status': response_status,
                  'Reason': 'See CloudWatch Logs',
                  'PhysicalResourceId': 'XRayTracesSetup',
                  'StackId': event['StackId'],
                  'RequestId': event['RequestId'],
                  'LogicalResourceId': event['LogicalResourceId'],
                  'Data': response_data
              }

              json_response_body = json.dumps(response_body)

              headers = {
                  'content-type': '',
                  'content-length': str(len(json_response_body))
              }

              http = urllib3.PoolManager()
              response = http.request('PUT', event['ResponseURL'], body=json_response_body, headers=headers)
              logger.info(f"Response status: {response.status}")
      Tags:
        - Key: Name
          Value: !Sub 'csvpc-${Environment}-XRay-Traces-Setup-Function'

  # Custom Resource to Setup X-Ray Traces
  XRayTracesSetup:
    Type: AWS::CloudFormation::CustomResource
    DependsOn: MCPDynamoDBRuntime
    Properties:
      ServiceToken: !GetAtt XRayTracesSetupFunction.Arn

  AgentRuntimeLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupClass: STANDARD
      LogGroupName: !Sub "/aws/vendedlogs/bedrock-agentcore/${MCPDynamoDBRuntime.AgentRuntimeId}"

  AgentRuntimeDeliverSourceApplicationLogs:
    Type: AWS::Logs::DeliverySource
    Properties:
      LogType: APPLICATION_LOGS
      Name: !Sub "${MCPDynamoDBRuntime.AgentRuntimeId}-logs-source"
      ResourceArn: !GetAtt MCPDynamoDBRuntime.AgentRuntimeArn

  AgentRuntimeDeliveryDestination:
    Type: AWS::Logs::DeliveryDestination
    Properties:
      DeliveryDestinationType: "CWL"
      DestinationResourceArn: !GetAtt AgentRuntimeLogGroup.Arn
      Name: !Sub "${MCPDynamoDBRuntime.AgentRuntimeId}-logs-destination"

  AgentRuntimeDeliveryApplicationLogs:
    Type: AWS::Logs::Delivery
    Properties:
      DeliveryDestinationArn: !GetAtt AgentRuntimeDeliveryDestination.Arn
      DeliverySourceName: !Sub "${MCPDynamoDBRuntime.AgentRuntimeId}-logs-source"


  # SSM Parameter for MCP Runtime ARN
  MCPRuntimeArnParameter:
    Type: AWS::SSM::Parameter
    Properties:
      Name: /app/customersupportvpc/mcp/mcp_runtime_arn
      Type: String
      Value: !GetAtt MCPDynamoDBRuntime.AgentRuntimeArn
      Description: MCP Runtime ARN
      Tags:
        Application: CustomerSupportVPC

  # SSM Parameter for MCP Provider Name
  MCPProviderNameParameter:
    Type: AWS::SSM::Parameter
    Properties:
      Name: /app/customersupportvpc/mcp/mcp_provider_name
      Type: String
      Value: !Sub 'MCPOAuth2Provider-csvpc-${Environment}'
      Description: MCP OAuth2 Provider Name
      Tags:
        Application: CustomerSupportVPC

Outputs:
  StackName:
    Description: 'Stack name for cross-stack references'
    Value: !Ref AWS::StackName
    Export:
      Name: !Sub '${AWS::StackName}-StackName'

  MCPDynamoDBRuntimeArn:
    Description: 'ARN of the BedrockAgentCore MCP DynamoDB Runtime'
    Value: !GetAtt MCPDynamoDBRuntime.AgentRuntimeArn
    Export:
      Name: !Sub '${AWS::StackName}-MCPDynamoDBRuntimeArn'

  MCPDynamoDBRuntimeId:
    Description: 'ID of the BedrockAgentCore MCP DynamoDB Runtime'
    Value: !GetAtt MCPDynamoDBRuntime.AgentRuntimeId
    Export:
      Name: !Sub '${AWS::StackName}-MCPDynamoDBRuntimeId'

  MCPDynamoDBRuntimeName:
    Description: 'Name of the BedrockAgentCore MCP DynamoDB Runtime'
    Value: !Ref MCPDynamoDBRuntime
    Export:
      Name: !Sub '${AWS::StackName}-MCPDynamoDBRuntimeName'
  
  MCPProviderName: 
    Description: 'Name of the MCP provider'
    Value: !Sub 'MCPOAuth2Provider-csvpc-${Environment}'
    Export:
      Name: !Sub '${AWS::StackName}-MCPProviderName'
